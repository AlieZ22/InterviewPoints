## C++基础

**<<<指针与引用**

指针本身是一个变量（32位系统为4字节，64位为8字节），本身有地址，用来存放某个对象的地址。可变，包括它所指向地址的改变和所指向地址中所存放的数据的改变。

引用就是变量的别名，从一而终，是不可变的，而且必须初始化。

不存在指向空值的引用，但是存在指向空值的指针。

**<<<const关键字的作用**

被const修饰的值不能改变，是只读变量。必须在定义的时候就给它赋值。

1. 常量指针（底层const）：若const在星号左边，说明指针所指对象是const，不可改变，但是可以改变指针所指向的地址。
2. 指针常量（顶层const）：若const在星号右边，说明指针所指向的地址不可改变，但是所指对象可以改变。

**<<<define和typedef的区别**

define：是宏定义

- 进行简单的字符串替换，没有类型检查
- 在编译的预处理阶段起作用
- 可以用来防止头文件重复使用（#ifndef, #define, #endif, 或者#paragram once）
- 不分配内存，使用多少次就进行多少次替换

typedef：是一种类型别名

- 有对应的数据类型，需要进行判断
- 在编译、运行的时候起作用
- 在静态存储区中分配空间，在程序运行过程内存中只有一个拷贝

**<<<define与inline的区别**

define：预处理时的宏定义，进行简单的字符串替换，无类型检查，是不安全的

inline：将内联函数编译完成后生成的函数体直接插入到被调用的地方，减少了压栈，跳转和返回的操作，没有了普通函数调用时的额外开销。会进行类型检查。

inline存在一些使用限制：不能存在循环，过多的条件判断，函数体不能过于庞大。

类的成员函数如果在类内定义，那么默认是inline的，所以建议是将类的声明和定义分开，含大量码的函数不作为inline函数，而规模小的成员函数作为inline函数。

**<<<重载、覆盖和名称隐藏**

（1）重载：发生在同一个类中。同名函数具有不同的参数列表（参数的类型，个数以及顺序）

（2）覆盖：发生在基类与派生类中。**函数名，参数列**都必须与父类相同，同时基类函数必须有virtual关键字。[覆盖相当于把函数指针指向的函数替换了]。注意：返回类型可以不一样。

（3）隐藏：发生在基类与派生类中。基类与派生类存在同名函数，不论参数列表是否相同，不论是否有virtual。

即使知道了有隐藏这回事，但是不知道隐藏背后发生了什么。**隐藏机制触发之后，指针的调用仅取决于指针的类型**！

例如：假设A中为void foo(float a)，B中为void foo(int a): 做如下调用: 

B *pb=&b; pb->foo(3.14); 

因为触发了隐藏机制，基类的void foo(float)会被隐藏，所以这里调用的仍然是派生类中的void foo(int)

**<<<new和malloc**

|              | new / delete                                                 | malloc / free                                                |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 本质属性     | C++运算符                                                    | C/C++标准库函数                                              |
| 内存分配大小 | 自动计算                                                     | 手工计算                                                     |
| 类型安全     | 是（一个int类型指针指向float会报错）                         | 不是（malloc转换成int，分配double类型的内存空间，不会报错）  |
| 特性         | 1，除了分配和释放内存，还会调用构造和析构函数；<br />2，内存分配失败时抛出bad_alloc异常；<br />3，返回定义时指定的具体类型的指针。 | 1，只分配和释放内存；<br />2，内存分配失败时返回null；<br />3，返回的是void类型的指针，使用时需要进行类型转换。 |

它们的关系是：new / delete 包装了 malloc / free。

**<<<constexpr和const**

constexpr是C++11新添加的关键字，表示“常量”的语义；而const却存在两种语义（“只读”和“常量”）。例如：

```c++
// 错误！const参数表示x在dis_1中只读，并非常量
void dis_1(const int x){
    array<int, x> myarr{1,2,3,4,5};
}
// 正确，这里的const表示常量语义
void dis_2(){
	const int x = 5;          // 更好的表达是使用 constexpr
    array<int, x> myarr{1,2,3,4,5};
}
```

constexpr就是为了解决const的语义二义性，将“常量”留给constexpr表达，“只读”留给const表达。

用constexpr修饰指针，仅对指针有效，即指针指向不可改变，但是所指的数据是可以改变的：

```c++
constexpr int *p = nullptr;       // 常量指针，顶层const
const int *p = nullptr;           // 指向常量的指针，底层const
int *const p = nullptr;           // 常量指针，顶层const
```

**<<<volatile**

用该关键字声明的变量表示<u>该变量随时可能发生变化</u>，与该变量有关的运算，不会被编译优化，从而可以**提供对特殊地址的稳定访问**。系统总是会重新从它所在的内存中读取数据，而不是直接从寄存器中拷贝内容。

详见：[C++中的volatile_龙行天下01的博客-CSDN博客_c++ volatile](https://blog.csdn.net/whl0071/article/details/125395653)

使用场景：中断服务程序 + cpu相关寄存器的定义

经典案例，空循环。想要测试空循环的速度：

```c++
for(int i=0; i<1000000; i++);            // 错误！编译器会优化，读取过程其实根本没有执行。
for(volatile int i=0; i<1000000; i++);   // 正确，编译器不会优化了。
```

**<<<前置++和后置++**

```c++
self& operator++(){             // 前置++
    node = (linktype)((node).next);
    return *this;
}

const self operator++(int){     // 后置++
	self temp = *this;
    ++*this;    // 调用前置++
    return temp;
}
```

前后置++是以重载函数的参数来区分的，后置++的参数有个int，在调用的时候编译器会默默地将这个int指定为一个0.

1. 前置++返回引用（是左值），而后置++返回对象（是右值）。后置++需要创建临时对象，所以无法返回引用。
2. 后置++函数返回值加了const。其实不加也可以，这是为了防止连续使用++++。
3. 最好使用前置++，不会创建临时对象，也没有构造和析构的开销。

**<<<std::automic**

